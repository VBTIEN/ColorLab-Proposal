"""
Professional AI Analysis Engine
Advanced image analysis with sophisticated AI reasoning
"""
import boto3
import json
import numpy as np
from datetime import datetime

class ProfessionalAIEngine:
    def __init__(self):
        self.bedrock = boto3.client('bedrock-runtime')
        self.analysis_frameworks = {
            'photography': self._photography_framework,
            'art_analysis': self._art_analysis_framework,
            'technical_quality': self._technical_quality_framework,
            'composition': self._composition_framework,
            'color_theory': self._color_theory_framework
        }
    
    def comprehensive_analysis(self, image_data, technical_metrics):
        """
        Perform comprehensive professional analysis using multiple AI frameworks
        """
        try:
            # Multi-framework analysis
            analyses = {}
            
            for framework_name, framework_func in self.analysis_frameworks.items():
                try:
                    analysis = framework_func(image_data, technical_metrics)
                    analyses[framework_name] = analysis
                except Exception as e:
                    print(f"Framework {framework_name} failed: {str(e)}")
                    analyses[framework_name] = {'error': str(e)}
            
            # Synthesize comprehensive analysis
            final_analysis = self._synthesize_analysis(analyses, technical_metrics)
            
            return {
                'comprehensive_analysis': final_analysis,
                'framework_analyses': analyses,
                'analysis_quality': 'professional',
                'confidence_score': self._calculate_confidence(analyses),
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"Professional AI Engine error: {str(e)}")
            return self._fallback_professional_analysis(technical_metrics)
    
    def _photography_framework(self, image_data, metrics):
        """Photography-focused analysis framework"""
        
        prompt = self._create_photography_prompt(image_data, metrics)
        
        return self._call_bedrock_with_advanced_prompt(
            prompt, 
            "photography_expert",
            temperature=0.3,  # Lower temperature for technical accuracy
            max_tokens=1500
        )
    
    def _art_analysis_framework(self, image_data, metrics):
        """Art and aesthetic analysis framework"""
        
        prompt = self._create_art_analysis_prompt(image_data, metrics)
        
        return self._call_bedrock_with_advanced_prompt(
            prompt,
            "art_critic",
            temperature=0.5,  # Moderate temperature for creative analysis
            max_tokens=1200
        )
    
    def _technical_quality_framework(self, image_data, metrics):
        """Technical quality assessment framework"""
        
        prompt = self._create_technical_prompt(image_data, metrics)
        
        return self._call_bedrock_with_advanced_prompt(
            prompt,
            "technical_expert",
            temperature=0.2,  # Very low temperature for precise technical analysis
            max_tokens=1000
        )
    
    def _composition_framework(self, image_data, metrics):
        """Composition and visual design framework"""
        
        prompt = self._create_composition_prompt(image_data, metrics)
        
        return self._call_bedrock_with_advanced_prompt(
            prompt,
            "composition_expert",
            temperature=0.4,
            max_tokens=1200
        )
    
    def _color_theory_framework(self, image_data, metrics):
        """Color theory and psychology framework"""
        
        prompt = self._create_color_theory_prompt(image_data, metrics)
        
        return self._call_bedrock_with_advanced_prompt(
            prompt,
            "color_theorist",
            temperature=0.4,
            max_tokens=1000
        )
    
    def _create_photography_prompt(self, image_data, metrics):
        """Create sophisticated photography analysis prompt"""
        
        # Extract key technical data
        quality_metrics = metrics.get('quality_metrics', {})
        color_analysis = metrics.get('low_level_features', {}).get('color_analysis', {})
        objects = metrics.get('high_level_features', {}).get('objects', [])
        faces = metrics.get('high_level_features', {}).get('faces', [])
        
        # Determine image category
        image_category = self._categorize_image(objects, faces)
        
        prompt = f"""
        B·∫°n l√† m·ªôt nhi·∫øp ·∫£nh gia chuy√™n nghi·ªáp v·ªõi 20 nƒÉm kinh nghi·ªám, ƒë∆∞·ª£c ƒë√†o t·∫°o b√†i b·∫£n v·ªÅ k·ªπ thu·∫≠t v√† th·∫©m m·ªπ nhi·∫øp ·∫£nh. H√£y ph√¢n t√≠ch b·ª©c ·∫£nh {image_category} n√†y v·ªõi g√≥c nh√¨n chuy√™n nghi·ªáp.

        üìä D·ªÆ LI·ªÜU K·ª∏ THU·∫¨T:
        - ƒê·ªô s√°ng: {quality_metrics.get('brightness', 'N/A')}
        - ƒê·ªô s·∫Øc n√©t: {quality_metrics.get('sharpness', 'N/A')}
        - ƒê·ªô t∆∞∆°ng ph·∫£n: {quality_metrics.get('contrast', 'N/A')}
        - ƒêi·ªÉm ch·∫•t l∆∞·ª£ng t·ªïng th·ªÉ: {quality_metrics.get('overall_quality_score', 'N/A')}
        - M√†u s·∫Øc ch·ªß ƒë·∫°o: {self._format_colors(color_analysis.get('dominant_colors', []))}
        - ƒê·ªëi t∆∞·ª£ng ch√≠nh: {self._format_objects(objects[:5])}
        - S·ªë ng∆∞·ªùi: {len(faces)}

        üéØ Y√äU C·∫¶U PH√ÇN T√çCH CHUY√äN NGHI·ªÜP:

        1. **ƒê√ÅNH GI√Å K·ª∏ THU·∫¨T** (Technical Assessment):
           - Ph√¢n t√≠ch exposure, focus, v√† depth of field
           - ƒê√°nh gi√° noise, dynamic range, v√† color accuracy
           - Nh·∫≠n x√©t v·ªÅ camera settings v√† lens characteristics

        2. **COMPOSITION ANALYSIS**:
           - Rule of thirds, leading lines, framing
           - Balance, symmetry, v√† visual weight distribution
           - Foreground, middle ground, background relationship

        3. **LIGHTING ANALYSIS**:
           - Ch·∫•t l∆∞·ª£ng v√† h∆∞·ªõng √°nh s√°ng
           - Hard vs soft light, color temperature
           - Shadow v√† highlight management

        4. **AESTHETIC EVALUATION**:
           - Visual impact v√† emotional response
           - Style v√† genre classification
           - Artistic merit v√† creative execution

        5. **PROFESSIONAL RECOMMENDATIONS**:
           - C·∫£i thi·ªán k·ªπ thu·∫≠t c·ª• th·ªÉ
           - Alternative shooting approaches
           - Post-processing suggestions

        Vi·∫øt ph√¢n t√≠ch 6-8 c√¢u, s·ª≠ d·ª•ng thu·∫≠t ng·ªØ chuy√™n nghi·ªáp nh∆∞ng d·ªÖ hi·ªÉu. T·∫≠p trung v√†o insights s√¢u s·∫Øc v√† practical advice.
        """
        
        return prompt
    
    def _create_art_analysis_prompt(self, image_data, metrics):
        """Create sophisticated art analysis prompt"""
        
        color_analysis = metrics.get('low_level_features', {}).get('color_analysis', {})
        spatial_features = metrics.get('low_level_features', {}).get('spatial_features', {})
        
        prompt = f"""
        B·∫°n l√† m·ªôt nh√† ph√™ b√¨nh ngh·ªá thu·∫≠t v√† gi√°o s∆∞ m·ªπ thu·∫≠t v·ªõi chuy√™n m√¥n s√¢u v·ªÅ l√Ω thuy·∫øt m√†u s·∫Øc, composition, v√† t√¢m l√Ω h·ªçc th·ªã gi√°c.

        üé® D·ªÆ LI·ªÜU TH·∫®M M·ª∏:
        - Harmony m√†u s·∫Øc: {color_analysis.get('color_harmony', {}).get('harmony_type', 'N/A')}
        - ƒêi·ªÉm harmony: {color_analysis.get('color_harmony', {}).get('harmony_score', 'N/A')}
        - Composition type: {spatial_features.get('composition_type', 'N/A')}
        - Balance score: {spatial_features.get('balance_score', 'N/A')}
        - Focal points: {spatial_features.get('focal_points', 'N/A')}

        üé≠ PH√ÇN T√çCH NGH·ªÜ THU·∫¨T CHUY√äN S√ÇU:

        1. **COLOR PSYCHOLOGY & THEORY**:
           - √ù nghƒ©a t√¢m l√Ω c·ªßa color palette
           - Color relationships v√† emotional impact
           - Cultural v√† symbolic associations

        2. **VISUAL HIERARCHY & FLOW**:
           - Eye movement patterns
           - Visual emphasis v√† focal points
           - Gestalt principles application

        3. **AESTHETIC PHILOSOPHY**:
           - Art movement influences
           - Style classification v√† historical context
           - Conceptual depth v√† meaning

        4. **EMOTIONAL RESONANCE**:
           - Mood v√† atmosphere creation
           - Viewer engagement strategies
           - Psychological impact assessment

        5. **ARTISTIC MERIT**:
           - Originality v√† creative vision
           - Technical skill demonstration
           - Cultural v√† social relevance

        Ph√¢n t√≠ch v·ªõi g√≥c nh√¨n c·ªßa m·ªôt art critic chuy√™n nghi·ªáp, s·ª≠ d·ª•ng terminology ch√≠nh x√°c v√† insights s√¢u s·∫Øc.
        """
        
        return prompt
    
    def _create_technical_prompt(self, image_data, metrics):
        """Create technical quality assessment prompt"""
        
        quality_metrics = metrics.get('quality_metrics', {})
        
        prompt = f"""
        B·∫°n l√† m·ªôt k·ªπ s∆∞ h√¨nh ·∫£nh v√† technical director v·ªõi expertise v·ªÅ image processing, optics, v√† digital imaging technology.

        üî¨ TECHNICAL SPECIFICATIONS:
        - Brightness: {quality_metrics.get('brightness', 'N/A')}
        - Sharpness: {quality_metrics.get('sharpness', 'N/A')}
        - Contrast: {quality_metrics.get('contrast', 'N/A')}
        - Quality Category: {quality_metrics.get('quality_category', 'N/A')}
        - Technical Assessment: {quality_metrics.get('technical_assessment', {})}

        ‚öôÔ∏è TECHNICAL ANALYSIS FRAMEWORK:

        1. **IMAGE QUALITY METRICS**:
           - SNR (Signal-to-Noise Ratio) assessment
           - MTF (Modulation Transfer Function) analysis
           - Dynamic range evaluation

        2. **OPTICAL CHARACTERISTICS**:
           - Lens performance indicators
           - Aberration analysis (chromatic, spherical)
           - Distortion v√† vignetting assessment

        3. **DIGITAL PROCESSING QUALITY**:
           - Compression artifacts detection
           - Color space v√† gamut analysis
           - Bit depth v√† tonal range evaluation

        4. **TECHNICAL STANDARDS COMPLIANCE**:
           - Industry standard benchmarks
           - Professional workflow compatibility
           - Print v√† display optimization

        5. **IMPROVEMENT RECOMMENDATIONS**:
           - Specific technical adjustments
           - Equipment upgrade suggestions
           - Workflow optimization tips

        Ph√¢n t√≠ch v·ªõi ƒë·ªô ch√≠nh x√°c k·ªπ thu·∫≠t cao, s·ª≠ d·ª•ng metrics c·ª• th·ªÉ v√† professional terminology.
        """
        
        return prompt
    
    def _create_composition_prompt(self, image_data, metrics):
        """Create composition analysis prompt"""
        
        spatial_features = metrics.get('low_level_features', {}).get('spatial_features', {})
        
        prompt = f"""
        B·∫°n l√† m·ªôt visual design expert v√† composition specialist v·ªõi background v·ªÅ graphic design, photography, v√† visual communication.

        üìê COMPOSITION DATA:
        - Composition Analysis: {spatial_features.get('composition_analysis', {})}
        - Visual Center of Mass: {spatial_features.get('spatial_distribution', {}).get('visual_center_of_mass', {})}
        - Focal Points: {spatial_features.get('focal_points', {})}

        üéØ COMPOSITION ANALYSIS FRAMEWORK:

        1. **GEOMETRIC PRINCIPLES**:
           - Rule of thirds application
           - Golden ratio v√† fibonacci spirals
           - Symmetry v√† asymmetry balance

        2. **VISUAL WEIGHT DISTRIBUTION**:
           - Element placement strategy
           - Negative space utilization
           - Visual tension creation

        3. **DEPTH & DIMENSION**:
           - Layering techniques
           - Perspective v√† vanishing points
           - Foreground/background relationships

        4. **MOVEMENT & RHYTHM**:
           - Leading lines effectiveness
           - Pattern v√† repetition usage
           - Visual flow optimization

        5. **DESIGN PRINCIPLES**:
           - Unity v√† coherence
           - Contrast v√† emphasis
           - Proportion v√† scale relationships

        Ph√¢n t√≠ch v·ªõi expertise c·ªßa m·ªôt professional designer, focusing on actionable composition insights.
        """
        
        return prompt
    
    def _create_color_theory_prompt(self, image_data, metrics):
        """Create color theory analysis prompt"""
        
        color_analysis = metrics.get('low_level_features', {}).get('color_analysis', {})
        
        prompt = f"""
        B·∫°n l√† m·ªôt color theorist v√† visual psychology expert v·ªõi deep knowledge v·ªÅ color science, perception, v√† cultural color meanings.

        üåà COLOR DATA:
        - Dominant Colors: {color_analysis.get('dominant_colors', [])}
        - Color Harmony: {color_analysis.get('color_harmony', {})}
        - Brightness Stats: {color_analysis.get('brightness_stats', {})}
        - Saturation Stats: {color_analysis.get('saturation_stats', {})}

        üé® COLOR THEORY ANALYSIS:

        1. **COLOR SCIENCE**:
           - Hue, saturation, brightness relationships
           - Color temperature analysis
           - Chromatic v√† achromatic balance

        2. **PSYCHOLOGICAL IMPACT**:
           - Emotional responses to color combinations
           - Cultural color associations
           - Mood v√† atmosphere creation

        3. **HARMONY PRINCIPLES**:
           - Complementary, analogous, triadic schemes
           - Color discord v√† tension effects
           - Palette sophistication level

        4. **PERCEPTUAL EFFECTS**:
           - Simultaneous contrast phenomena
           - Color constancy considerations
           - Visual comfort v√† accessibility

        5. **PROFESSIONAL APPLICATION**:
           - Brand identity implications
           - Market psychology considerations
           - Cross-cultural color meanings

        Ph√¢n t√≠ch v·ªõi scientific rigor v√† practical color expertise.
        """
        
        return prompt
    
    def _call_bedrock_with_advanced_prompt(self, prompt, expert_role, temperature=0.5, max_tokens=1200):
        """Call Bedrock with advanced prompting techniques"""
        
        try:
            # Enhanced system prompt for role-playing
            system_prompt = f"""
            B·∫°n ƒëang ƒë√≥ng vai m·ªôt {expert_role} h√†ng ƒë·∫ßu th·∫ø gi·ªõi. H√£y ph√¢n t√≠ch v·ªõi:
            - Chuy√™n m√¥n s√¢u v√† kinh nghi·ªám th·ª±c t·∫ø
            - Terminology ch√≠nh x√°c v√† professional
            - Insights ƒë·ªôc ƒë√°o v√† actionable advice
            - Balanced perspective gi·ªØa technical v√† creative
            - Vietnamese fluency v·ªõi international expertise
            """
            
            # Try Claude 3 first
            models_to_try = [
                'anthropic.claude-3-sonnet-20240229-v1:0',
                'anthropic.claude-3-haiku-20240307-v1:0',
                'anthropic.claude-v2:1'
            ]
            
            for model_id in models_to_try:
                try:
                    if 'claude-3' in model_id:
                        response = self.bedrock.invoke_model(
                            modelId=model_id,
                            body=json.dumps({
                                'anthropic_version': 'bedrock-2023-05-31',
                                'max_tokens': max_tokens,
                                'temperature': temperature,
                                'system': system_prompt,
                                'messages': [
                                    {
                                        'role': 'user',
                                        'content': prompt
                                    }
                                ]
                            })
                        )
                        
                        response_body = json.loads(response['body'].read())
                        analysis = response_body['content'][0]['text']
                        
                    else:
                        # Claude 2 format
                        full_prompt = f"{system_prompt}\n\nHuman: {prompt}\n\nAssistant:"
                        
                        response = self.bedrock.invoke_model(
                            modelId=model_id,
                            body=json.dumps({
                                'prompt': full_prompt,
                                'max_tokens_to_sample': max_tokens,
                                'temperature': temperature,
                                'top_p': 0.9,
                                'stop_sequences': ['\n\nHuman:']
                            })
                        )
                        
                        response_body = json.loads(response['body'].read())
                        analysis = response_body['completion']
                    
                    return {
                        'analysis': analysis.strip(),
                        'model_used': model_id,
                        'expert_role': expert_role,
                        'confidence': 'high',
                        'temperature': temperature
                    }
                    
                except Exception as model_error:
                    print(f"Model {model_id} failed: {str(model_error)}")
                    continue
            
            raise Exception("All Bedrock models failed")
            
        except Exception as e:
            print(f"Advanced Bedrock call failed: {str(e)}")
            return {
                'analysis': f"Advanced AI analysis temporarily unavailable. Error: {str(e)}",
                'model_used': 'fallback',
                'expert_role': expert_role,
                'confidence': 'low'
            }
    
    def _synthesize_analysis(self, analyses, technical_metrics):
        """Synthesize multiple framework analyses into comprehensive assessment"""
        
        try:
            # Extract successful analyses
            successful_analyses = {k: v for k, v in analyses.items() 
                                 if 'error' not in v and 'analysis' in v}
            
            if not successful_analyses:
                return self._fallback_professional_analysis(technical_metrics)
            
            # Create synthesis prompt
            synthesis_prompt = f"""
            B·∫°n l√† m·ªôt Master Analyst v·ªõi expertise t·ªïng h·ª£p t·ª´ nhi·ªÅu chuy√™n gia. H√£y t·ªïng h·ª£p c√°c ph√¢n t√≠ch chuy√™n m√¥n sau th√†nh m·ªôt ƒë√°nh gi√° to√†n di·ªán:

            üìä C√ÅC PH√ÇN T√çCH CHUY√äN M√îN:
            """
            
            for framework, analysis in successful_analyses.items():
                synthesis_prompt += f"\n\nüîπ {framework.upper()}:\n{analysis.get('analysis', '')}"
            
            synthesis_prompt += f"""

            üéØ Y√äU C·∫¶U T·ªîNG H·ª¢P:
            1. T·∫°o m·ªôt ƒë√°nh gi√° t·ªïng th·ªÉ coherent v√† professional
            2. Highlight nh·ªØng insights quan tr·ªçng nh·∫•t
            3. Resolve b·∫•t k·ª≥ contradictions n√†o gi·ªØa c√°c analyses
            4. Provide actionable recommendations
            5. Maintain professional tone v√† technical accuracy

            Vi·∫øt 1 ƒëo·∫°n vƒÉn 6-8 c√¢u, t·ªïng h·ª£p tinh hoa t·ª´ t·∫•t c·∫£ c√°c g√≥c nh√¨n chuy√™n m√¥n.
            """
            
            # Call Bedrock for synthesis
            synthesis_result = self._call_bedrock_with_advanced_prompt(
                synthesis_prompt,
                "master_analyst",
                temperature=0.4,
                max_tokens=1000
            )
            
            return {
                'comprehensive_analysis': synthesis_result.get('analysis', ''),
                'synthesis_quality': 'high',
                'frameworks_used': list(successful_analyses.keys()),
                'model_used': synthesis_result.get('model_used', 'unknown')
            }
            
        except Exception as e:
            print(f"Synthesis failed: {str(e)}")
            return self._fallback_professional_analysis(technical_metrics)
    
    def _calculate_confidence(self, analyses):
        """Calculate overall confidence score based on successful analyses"""
        
        successful_count = sum(1 for analysis in analyses.values() 
                             if 'error' not in analysis and 'analysis' in analysis)
        total_frameworks = len(analyses)
        
        base_confidence = (successful_count / total_frameworks) * 100
        
        # Adjust based on analysis quality indicators
        quality_bonus = 0
        for analysis in analyses.values():
            if analysis.get('confidence') == 'high':
                quality_bonus += 10
            elif analysis.get('confidence') == 'medium':
                quality_bonus += 5
        
        final_confidence = min(100, base_confidence + quality_bonus)
        
        return round(final_confidence, 1)
    
    def _categorize_image(self, objects, faces):
        """Categorize image type for specialized analysis"""
        
        if len(faces) > 0:
            return "ch√¢n dung" if len(faces) == 1 else "·∫£nh nh√≥m"
        
        object_names = [obj.get('name', '').lower() for obj in objects[:5]]
        
        nature_keywords = ['landscape', 'mountain', 'tree', 'sky', 'water', 'nature']
        architecture_keywords = ['building', 'architecture', 'house', 'bridge']
        street_keywords = ['street', 'car', 'road', 'urban', 'city']
        
        if any(keyword in ' '.join(object_names) for keyword in nature_keywords):
            return "phong c·∫£nh t·ª± nhi√™n"
        elif any(keyword in ' '.join(object_names) for keyword in architecture_keywords):
            return "ki·∫øn tr√∫c"
        elif any(keyword in ' '.join(object_names) for keyword in street_keywords):
            return "street photography"
        else:
            return "ngh·ªá thu·∫≠t t·ªïng h·ª£p"
    
    def _format_colors(self, colors):
        """Format color data for prompt"""
        if not colors:
            return "Kh√¥ng x√°c ƒë·ªãnh"
        
        return ", ".join([f"{color.get('color', 'Unknown')} ({color.get('pixel_percent', 0):.1f}%)" 
                         for color in colors[:3]])
    
    def _format_objects(self, objects):
        """Format object data for prompt"""
        if not objects:
            return "Kh√¥ng x√°c ƒë·ªãnh"
        
        return ", ".join([f"{obj.get('name', 'Unknown')} ({obj.get('confidence', 0):.1f}%)" 
                         for obj in objects])
    
    def _fallback_professional_analysis(self, technical_metrics):
        """Professional fallback analysis when AI fails"""
        
        quality_metrics = technical_metrics.get('quality_metrics', {})
        color_analysis = technical_metrics.get('low_level_features', {}).get('color_analysis', {})
        
        # Rule-based professional analysis
        analysis_parts = []
        
        # Technical assessment
        brightness = quality_metrics.get('brightness', 50)
        sharpness = quality_metrics.get('sharpness', 50)
        contrast = quality_metrics.get('contrast', 50)
        
        if sharpness > 80:
            analysis_parts.append("·∫¢nh th·ªÉ hi·ªán ƒë·ªô s·∫Øc n√©t xu·∫•t s·∫Øc v·ªõi chi ti·∫øt r√µ r√†ng, cho th·∫•y k·ªπ thu·∫≠t focus ch√≠nh x√°c")
        elif sharpness > 60:
            analysis_parts.append("ƒê·ªô s·∫Øc n√©t ·ªü m·ª©c t·ªët, ph√π h·ª£p v·ªõi m·ª•c ƒë√≠ch s·ª≠ d·ª•ng chuy√™n nghi·ªáp")
        else:
            analysis_parts.append("C·∫ßn c·∫£i thi·ªán ƒë·ªô s·∫Øc n√©t ƒë·ªÉ ƒë·∫°t ti√™u chu·∫©n chuy√™n nghi·ªáp")
        
        # Color analysis
        dominant_colors = color_analysis.get('dominant_colors', [])
        if len(dominant_colors) >= 3:
            analysis_parts.append("B·∫£ng m√†u phong ph√∫ t·∫°o visual interest cao, th·ªÉ hi·ªán s·ª± hi·ªÉu bi·∫øt v·ªÅ color theory")
        elif len(dominant_colors) >= 2:
            analysis_parts.append("Color palette h√†i h√≤a v·ªõi t√¥ng m√†u c√¢n b·∫±ng, ph√π h·ª£p v·ªõi aesthetic hi·ªán ƒë·∫°i")
        
        # Composition assessment
        if quality_metrics.get('overall_quality_score', 50) > 70:
            analysis_parts.append("Composition t·ªïng th·ªÉ ƒë·∫°t ti√™u chu·∫©n chuy√™n nghi·ªáp v·ªõi technical execution t·ªët")
        
        # Professional recommendations
        recommendations = []
        if brightness < 40:
            recommendations.append("ƒëi·ªÅu ch·ªânh exposure ƒë·ªÉ t·ªëi ∆∞u dynamic range")
        if contrast < 40:
            recommendations.append("tƒÉng c∆∞·ªùng contrast ƒë·ªÉ improve visual impact")
        
        if recommendations:
            analysis_parts.append(f"G·ª£i √Ω chuy√™n nghi·ªáp: {', '.join(recommendations)}")
        
        final_analysis = ". ".join(analysis_parts) + "."
        
        return {
            'comprehensive_analysis': final_analysis,
            'synthesis_quality': 'rule_based',
            'frameworks_used': ['technical_assessment', 'color_theory', 'composition'],
            'model_used': 'Professional Rule-based Analysis'
        }
