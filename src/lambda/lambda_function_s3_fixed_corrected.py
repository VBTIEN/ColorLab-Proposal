"""
AI Image Analyzer - S3 Folder Fix Version (Corrected)
S·ª≠a l·ªói folder structure - ch·ªâ ƒë·∫øn ng√†y, kh√¥ng c√≥ gi·ªù
"""
import json
import boto3
import base64
import uuid
from datetime import datetime
import traceback
import os
from botocore.exceptions import ClientError

# Initialize AWS clients
s3_client = boto3.client('s3')
rekognition_client = boto3.client('rekognition')
bedrock_client = boto3.client('bedrock-runtime')

def lambda_handler(event, context):
    """Main Lambda handler v·ªõi S3 folder fix (corrected)"""
    
    # CORS headers
    headers = {
        'Content-Type': 'application/json; charset=utf-8',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
        'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
    }
    
    try:
        print(f"üöÄ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω request: {event.get('httpMethod', 'UNKNOWN')}")
        
        # Handle CORS preflight
        if event.get('httpMethod') == 'OPTIONS':
            return {
                'statusCode': 200,
                'headers': headers,
                'body': json.dumps({'message': 'CORS preflight th√†nh c√¥ng'}, ensure_ascii=False)
            }
        
        # Parse request body
        if 'body' not in event:
            raise ValueError("Thi·∫øu d·ªØ li·ªáu request body")
        
        try:
            body = json.loads(event['body']) if isinstance(event['body'], str) else event['body']
        except json.JSONDecodeError:
            raise ValueError("D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá")
        
        # Validate required fields
        bucket = body.get('bucket', 'image-analyzer-workshop-1751722329')
        image_data = body.get('image_data')
        
        if not image_data:
            raise ValueError("Thi·∫øu d·ªØ li·ªáu ·∫£nh (image_data)")
        
        # Process image with corrected S3 folder structure
        result = process_image_with_corrected_s3_folder(bucket, image_data, context)
        
        return {
            'statusCode': 200,
            'headers': headers,
            'body': json.dumps(result, ensure_ascii=False)
        }
        
    except Exception as e:
        print(f"‚ùå L·ªói x·ª≠ l√Ω: {str(e)}")
        print(f"üìã Traceback: {traceback.format_exc()}")
        
        return {
            'statusCode': 500,
            'headers': headers,
            'body': json.dumps({
                'loi': str(e),
                'trang_thai': 'that_bai',
                'thoi_gian': datetime.now().isoformat()
            }, ensure_ascii=False)
        }

def process_image_with_corrected_s3_folder(bucket, image_data, context):
    """X·ª≠ l√Ω ·∫£nh v·ªõi S3 folder structure ƒë√£ s·ª≠a"""
    
    try:
        # 1. T·∫°o folder structure v√† key (CORRECTED)
        folder_structure = create_corrected_s3_folder_structure()
        unique_id = str(uuid.uuid4())
        key = f"{folder_structure}/{unique_id}.jpg"
        
        print(f"üìÅ T·∫°o folder structure (corrected): {folder_structure}")
        print(f"üîë S3 key ho√†n ch·ªânh: {key}")
        
        # 2. Decode v√† validate image data
        image_bytes = decode_and_validate_image(image_data)
        
        # 3. Ensure S3 folder structure exists
        ensure_s3_folder_exists(bucket, folder_structure)
        
        # 4. Upload image to S3
        upload_result = upload_image_to_s3(bucket, key, image_bytes, context)
        
        # 5. Analyze image
        analysis_result = analyze_image_comprehensive(bucket, key)
        
        # 6. Create comprehensive response
        result = {
            'thong_tin_anh': {
                'vi_tri_s3': f's3://{bucket}/{key}',
                'folder_structure': folder_structure,
                'thoi_gian_phan_tich': datetime.now().isoformat(),
                'phien_ban': '3.1_s3_folder_fix_corrected',
                'kich_thuoc': len(image_bytes),
                'upload_info': upload_result
            },
            'phan_tich_ky_thuat': analysis_result.get('technical_analysis', {}),
            'phan_tich_ai': analysis_result.get('ai_analysis', {}),
            'trang_thai': 'thanh_cong'
        }
        
        print(f"‚úÖ Ho√†n th√†nh x·ª≠ l√Ω ·∫£nh: {key}")
        return result
        
    except Exception as e:
        print(f"‚ùå L·ªói trong process_image_with_corrected_s3_folder: {str(e)}")
        raise

def create_corrected_s3_folder_structure():
    """T·∫°o c·∫•u tr√∫c folder theo th·ªùi gian (CORRECTED - ch·ªâ ƒë·∫øn ng√†y)"""
    now = datetime.now()
    
    # FIXED: Ch·ªâ t·∫°o folder ƒë·∫øn ng√†y, kh√¥ng c√≥ gi·ªù
    folder_structure = f"uploads/{now.strftime('%Y')}/{now.strftime('%m')}/{now.strftime('%d')}"
    
    print(f"üìÖ Folder structure corrected: {folder_structure}")
    return folder_structure

def ensure_s3_folder_exists(bucket, folder_path):
    """ƒê·∫£m b·∫£o folder structure t·ªìn t·∫°i trong S3"""
    try:
        # S3 kh√¥ng c√≥ folder th·ª±c s·ª±, nh∆∞ng ch√∫ng ta c√≥ th·ªÉ t·∫°o "marker" objects
        # ƒë·ªÉ ƒë·∫£m b·∫£o folder structure hi·ªÉn th·ªã trong console
        
        folder_parts = folder_path.split('/')
        current_path = ""
        
        for part in folder_parts:
            current_path += part + "/"
            folder_key = current_path
            
            # Ki·ªÉm tra xem folder marker ƒë√£ t·ªìn t·∫°i ch∆∞a
            try:
                s3_client.head_object(Bucket=bucket, Key=folder_key)
                print(f"üìÅ Folder ƒë√£ t·ªìn t·∫°i: {folder_key}")
            except ClientError as e:
                if e.response['Error']['Code'] == '404':
                    # T·∫°o folder marker (empty object v·ªõi trailing slash)
                    try:
                        s3_client.put_object(
                            Bucket=bucket,
                            Key=folder_key,
                            Body=b'',
                            ContentType='application/x-directory',
                            Metadata={
                                'created_at': datetime.now().isoformat(),
                                'type': 'folder_marker'
                            }
                        )
                        print(f"‚úÖ T·∫°o folder marker: {folder_key}")
                    except Exception as folder_error:
                        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o folder marker {folder_key}: {str(folder_error)}")
                        # Kh√¥ng raise error v√¨ folder marker kh√¥ng b·∫Øt bu·ªôc
                else:
                    print(f"‚ö†Ô∏è L·ªói ki·ªÉm tra folder {folder_key}: {str(e)}")
        
        print(f"‚úÖ Folder structure ƒë√£ s·∫µn s√†ng: {folder_path}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói t·∫°o folder structure: {str(e)}")
        # Kh√¥ng raise error v√¨ vi·ªác t·∫°o folder marker kh√¥ng b·∫Øt bu·ªôc

def decode_and_validate_image(image_data):
    """Decode v√† validate d·ªØ li·ªáu ·∫£nh"""
    try:
        # Remove data URL prefix if present
        if image_data.startswith('data:image'):
            image_data = image_data.split(',')[1]
        
        # Decode base64
        image_bytes = base64.b64decode(image_data)
        
        print(f"üìä K√≠ch th∆∞·ªõc ·∫£nh sau decode: {len(image_bytes)} bytes")
        
        # Validate image size
        if len(image_bytes) < 100:
            raise ValueError("D·ªØ li·ªáu ·∫£nh qu√° nh·ªè, c√≥ th·ªÉ b·ªã l·ªói")
        
        if len(image_bytes) > 10 * 1024 * 1024:  # 10MB limit
            raise ValueError("·∫¢nh qu√° l·ªõn (gi·ªõi h·∫°n 10MB)")
        
        # Basic image format validation
        if not (image_bytes.startswith(b'\xff\xd8') or  # JPEG
                image_bytes.startswith(b'\x89PNG') or   # PNG
                image_bytes.startswith(b'GIF')):        # GIF
            print("‚ö†Ô∏è C·∫£nh b√°o: ƒê·ªãnh d·∫°ng ·∫£nh c√≥ th·ªÉ kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£")
        
        return image_bytes
        
    except Exception as e:
        raise ValueError(f"Kh√¥ng th·ªÉ decode d·ªØ li·ªáu ·∫£nh: {str(e)}")

def upload_image_to_s3(bucket, key, image_bytes, context):
    """Upload ·∫£nh l√™n S3 v·ªõi error handling t·ªët"""
    try:
        print(f"üì§ ƒêang upload ·∫£nh l√™n S3: s3://{bucket}/{key}")
        
        # Determine content type
        content_type = 'image/jpeg'  # Default
        if image_bytes.startswith(b'\x89PNG'):
            content_type = 'image/png'
        elif image_bytes.startswith(b'GIF'):
            content_type = 'image/gif'
        
        # Upload with comprehensive metadata
        upload_response = s3_client.put_object(
            Bucket=bucket,
            Key=key,
            Body=image_bytes,
            ContentType=content_type,
            Metadata={
                'uploaded_at': datetime.now().isoformat(),
                'request_id': context.aws_request_id,
                'size_bytes': str(len(image_bytes)),
                'content_type': content_type,
                'version': '3.1_s3_folder_fix_corrected'
            },
            # Add tags for better organization
            Tagging='Type=ImageAnalysis&Version=3.1&AutoCreated=true'
        )
        
        print(f"‚úÖ Upload S3 th√†nh c√¥ng: s3://{bucket}/{key}")
        
        # Verify upload
        try:
            head_response = s3_client.head_object(Bucket=bucket, Key=key)
            file_size = head_response.get('ContentLength', 0)
            last_modified = head_response.get('LastModified', '')
            
            print(f"‚úÖ X√°c nh·∫≠n ·∫£nh tr√™n S3 - Size: {file_size} bytes, Modified: {last_modified}")
            
            return {
                'status': 'success',
                'etag': upload_response.get('ETag', ''),
                'size_bytes': file_size,
                'last_modified': str(last_modified),
                'content_type': content_type
            }
            
        except Exception as verify_error:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ x√°c nh·∫≠n upload: {str(verify_error)}")
            return {
                'status': 'uploaded_but_not_verified',
                'etag': upload_response.get('ETag', ''),
                'warning': str(verify_error)
            }
        
    except ClientError as e:
        error_code = e.response['Error']['Code']
        error_message = e.response['Error']['Message']
        
        print(f"‚ùå AWS S3 Error [{error_code}]: {error_message}")
        
        if error_code == 'NoSuchBucket':
            raise ValueError(f"S3 bucket '{bucket}' kh√¥ng t·ªìn t·∫°i")
        elif error_code == 'AccessDenied':
            raise ValueError(f"Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p S3 bucket '{bucket}'")
        else:
            raise ValueError(f"L·ªói S3 [{error_code}]: {error_message}")
    
    except Exception as e:
        print(f"‚ùå L·ªói upload S3: {str(e)}")
        raise ValueError(f"Kh√¥ng th·ªÉ upload ·∫£nh l√™n S3: {str(e)}")

def analyze_image_comprehensive(bucket, key):
    """Ph√¢n t√≠ch ·∫£nh to√†n di·ªán"""
    try:
        print(f"üîç B·∫Øt ƒë·∫ßu ph√¢n t√≠ch ·∫£nh: s3://{bucket}/{key}")
        
        # Basic Rekognition analysis
        rekognition_result = analyze_with_rekognition(bucket, key)
        
        # AI analysis with Bedrock (fallback if error)
        ai_analysis = analyze_with_bedrock_safe(rekognition_result)
        
        return {
            'technical_analysis': rekognition_result,
            'ai_analysis': ai_analysis
        }
        
    except Exception as e:
        print(f"‚ùå L·ªói ph√¢n t√≠ch ·∫£nh: {str(e)}")
        return {
            'technical_analysis': {'error': str(e)},
            'ai_analysis': {'error': 'Kh√¥ng th·ªÉ ph√¢n t√≠ch AI do l·ªói k·ªπ thu·∫≠t'}
        }

def analyze_with_rekognition(bucket, key):
    """Ph√¢n t√≠ch v·ªõi Amazon Rekognition"""
    try:
        # Detect labels
        labels_response = rekognition_client.detect_labels(
            Image={'S3Object': {'Bucket': bucket, 'Name': key}},
            MaxLabels=20,
            MinConfidence=70
        )
        
        # Detect faces
        faces_response = rekognition_client.detect_faces(
            Image={'S3Object': {'Bucket': bucket, 'Name': key}},
            Attributes=['ALL']
        )
        
        # Detect text
        text_response = rekognition_client.detect_text(
            Image={'S3Object': {'Bucket': bucket, 'Name': key}}
        )
        
        return {
            'doi_tuong_phat_hien': [
                {
                    'ten': label['Name'],
                    'do_tin_cay': round(label['Confidence'], 1)
                }
                for label in labels_response.get('Labels', [])
            ],
            'khuon_mat': len(faces_response.get('FaceDetails', [])),
            'van_ban_phat_hien': [
                text['DetectedText'] 
                for text in text_response.get('TextDetections', [])
                if text['Type'] == 'LINE'
            ]
        }
        
    except Exception as e:
        print(f"‚ùå L·ªói Rekognition: {str(e)}")
        return {'error': f'L·ªói ph√¢n t√≠ch Rekognition: {str(e)}'}

def analyze_with_bedrock_safe(rekognition_data):
    """Ph√¢n t√≠ch AI v·ªõi Bedrock (c√≥ fallback)"""
    try:
        # Create prompt for AI analysis
        prompt = f"""
        Ph√¢n t√≠ch chuy√™n nghi·ªáp b·ª©c ·∫£nh n√†y d·ª±a tr√™n d·ªØ li·ªáu k·ªπ thu·∫≠t:
        
        ƒê·ªëi t∆∞·ª£ng ph√°t hi·ªán: {rekognition_data.get('doi_tuong_phat_hien', [])}
        S·ªë khu√¥n m·∫∑t: {rekognition_data.get('khuon_mat', 0)}
        VƒÉn b·∫£n: {rekognition_data.get('van_ban_phat_hien', [])}
        
        H√£y ƒë∆∞a ra ph√¢n t√≠ch chuy√™n nghi·ªáp v·ªÅ:
        1. Composition v√† k·ªπ thu·∫≠t
        2. Ch·∫•t l∆∞·ª£ng v√† √°nh s√°ng
        3. N·ªôi dung v√† c·∫£m x√∫c
        4. G·ª£i √Ω c·∫£i thi·ªán
        
        Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, chuy√™n nghi·ªáp v√† chi ti·∫øt.
        """
        
        # Call Bedrock
        response = bedrock_client.invoke_model(
            modelId='anthropic.claude-3-sonnet-20240229-v1:0',
            body=json.dumps({
                'anthropic_version': 'bedrock-2023-05-31',
                'max_tokens': 1000,
                'temperature': 0.4,
                'messages': [
                    {
                        'role': 'user',
                        'content': prompt
                    }
                ]
            })
        )
        
        result = json.loads(response['body'].read())
        ai_analysis = result['content'][0]['text']
        
        return {
            'phan_tich_chuyen_nghiep': ai_analysis,
            'trang_thai': 'thanh_cong'
        }
        
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói Bedrock AI: {str(e)}")
        
        # Fallback analysis
        return {
            'phan_tich_chuyen_nghiep': create_fallback_analysis(rekognition_data),
            'trang_thai': 'fallback',
            'luu_y': 'S·ª≠ d·ª•ng ph√¢n t√≠ch d·ª± ph√≤ng do l·ªói AI'
        }

def create_fallback_analysis(rekognition_data):
    """T·∫°o ph√¢n t√≠ch d·ª± ph√≤ng khi AI kh√¥ng kh·∫£ d·ª•ng"""
    
    objects = rekognition_data.get('doi_tuong_phat_hien', [])
    faces = rekognition_data.get('khuon_mat', 0)
    texts = rekognition_data.get('van_ban_phat_hien', [])
    
    analysis = f"""
    üì∏ PH√ÇN T√çCH CHUY√äN NGHI·ªÜP (Phi√™n b·∫£n 3.1 - S3 Folder Fix Corrected)
    
    üîç N·ªòI DUNG PH√ÅT HI·ªÜN:
    """
    
    if objects:
        analysis += f"\n‚Ä¢ ƒê·ªëi t∆∞·ª£ng ch√≠nh: {', '.join([obj['ten'] for obj in objects[:5]])}"
        analysis += f"\n‚Ä¢ ƒê·ªô tin c·∫≠y trung b√¨nh: {sum([obj['do_tin_cay'] for obj in objects[:5]])/min(5, len(objects)):.1f}%"
    
    if faces > 0:
        analysis += f"\n‚Ä¢ Ph√°t hi·ªán {faces} khu√¥n m·∫∑t trong ·∫£nh"
    
    if texts:
        analysis += f"\n‚Ä¢ VƒÉn b·∫£n: {', '.join(texts[:3])}"
    
    analysis += f"""
    
    üé® ƒê√ÅNH GI√Å T·ªîNG QUAN:
    ‚Ä¢ ·∫¢nh ƒë√£ ƒë∆∞·ª£c upload th√†nh c√¥ng v·ªõi folder structure ƒë√£ s·ª≠a
    ‚Ä¢ H·ªá th·ªëng ph√¢n t√≠ch k·ªπ thu·∫≠t ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh
    ‚Ä¢ Ch·∫•t l∆∞·ª£ng d·ªØ li·ªáu ph√¢n t√≠ch: T·ªët
    
    ‚ú® T√çNH NƒÇNG M·ªöI (v3.1 Corrected):
    ‚Ä¢ ‚úÖ S3 Folder Structure: uploads/YYYY/MM/DD (ƒë√£ s·ª≠a l·ªói)
    ‚Ä¢ ‚úÖ Upload Verification: X√°c nh·∫≠n ·∫£nh ƒë√£ l∆∞u th√†nh c√¥ng
    ‚Ä¢ ‚úÖ Error Handling: X·ª≠ l√Ω l·ªói to√†n di·ªán
    ‚Ä¢ ‚úÖ Metadata: Th√¥ng tin chi ti·∫øt v·ªÅ upload
    
    üìä TH·ªêNG K√ä:
    ‚Ä¢ ƒê·ªëi t∆∞·ª£ng ph√°t hi·ªán: {len(objects)}
    ‚Ä¢ Khu√¥n m·∫∑t: {faces}
    ‚Ä¢ VƒÉn b·∫£n: {len(texts)}
    ‚Ä¢ Tr·∫°ng th√°i: Ho√†n th√†nh th√†nh c√¥ng
    """
    
    return analysis.strip()
